<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Unity Virtual Camera Controller</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 20px; }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
  button { padding:10px 14px; border:1px solid #ccc; border-radius:8px; background:#f6f6f6; }
  #status { padding:6px 10px; border-radius:999px; background:#eee; display:inline-block; }
  label { display:inline-flex; gap:6px; align-items:center; }
  input[type="range"] { width: 240px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
</style>
</head>
<body>
  <h1>Unity Virtual Camera Controller</h1>

  <div class="row">
    <span id="status">Disconnected</span>
  </div>

  <div class="row">
    <button id="permBtn">Enable Motion (iOS)</button>
    <button id="connectBtn">Connect</button>
    <button id="disconnectBtn">Disconnect</button>
    <button id="calibBtn">Zero / Calibrate</button>
  </div>

  <div class="row">
    <label> Smoothing
      <input id="smoothing" type="range" min="0" max="0.25" step="0.005" value="0.05">
      <span id="smoothVal" class="mono">0.05</span>
    </label>
    <label> Send Hz
      <input id="rate" type="range" min="10" max="120" step="5" value="60">
      <span id="rateVal" class="mono">60</span>
    </label>
    <label>
      Portrait
      <input type="radio" name="orient" value="portrait" checked>
    </label>
    <label>
      Landscape
      <input type="radio" name="orient" value="landscape">
    </label>
  </div>

  <pre id="debug" class="mono" style="white-space:pre-wrap; background:#fafafa; padding:10px; border:1px solid #eee; border-radius:8px;"></pre>

<script>
(() => {
  const statusEl = document.getElementById("status");
  const permBtn = document.getElementById("permBtn");
  const connectBtn = document.getElementById("connectBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const calibBtn = document.getElementById("calibBtn");
  const smoothing = document.getElementById("smoothing");
  const smoothVal = document.getElementById("smoothVal");
  const rate = document.getElementById("rate");
  const rateVal = document.getElementById("rateVal");
  const debug = document.getElementById("debug");
  const orientRadios = document.querySelectorAll('input[name="orient"]');

  let ws = null;
  let lastSendTime = 0;
  let sendIntervalMs = 1000/60;
  let useLandscape = false;

  // Raw sensor angles (deg)
  let alpha=0, beta=0, gamma=0;
  let gotOrientation = false;

  // Quaternion utilities (x, y, z, w)
  function qMultiply(a, b) {
    return [
      a[3]*b[0] + a[0]*b[3] + a[1]*b[2] - a[2]*b[1],
      a[3]*b[1] - a[0]*b[2] + a[1]*b[3] + a[2]*b[0],
      a[3]*b[2] + a[0]*b[1] - a[1]*b[0] + a[2]*b[3],
      a[3]*b[3] - a[0]*b[0] - a[1]*b[1] - a[2]*b[2],
    ];
  }
  function qConjugate(q){ return [-q[0],-q[1],-q[2],q[3]]; }
  function qNormalize(q){
    const m = Math.hypot(q[0],q[1],q[2],q[3]) || 1;
    return [q[0]/m,q[1]/m,q[2]/m,q[3]/m];
  }
  function qFromAxisAngle(ax, ay, az, angleRad){
    const s = Math.sin(angleRad/2);
    return [ax*s, ay*s, az*s, Math.cos(angleRad/2)];
  }
  // Euler->Quat for order Y-X-Z (angles in radians): rotate Y (β), then X (α), then Z (γ)
  function qFromEulerYXZ(betaRad, alphaRad, gammaRad){
    const cy = Math.cos(betaRad/2),  sy = Math.sin(betaRad/2);
    const cx = Math.cos(alphaRad/2), sx = Math.sin(alphaRad/2);
    const cz = Math.cos(gammaRad/2), sz = Math.sin(gammaRad/2);
    const x = cy*sx*cz + sy*cx*sz;
    const y = -cy*sx*sz + sy*cx*cz;
    const z = cy*cx*sz - sy*sx*cz;
    const w = cy*cx*cz + sy*sx*sz;
    return [x,y,z,w];
  }

  // Calibration: qAdj = qCalib * qRaw so that at the moment of calibration, qAdj ≈ identity
  let qCalib = [0,0,0,1];

  function computeQuaternion() {
    // Convert deviceorientation (alpha, beta, gamma in degrees) to quaternion similar to three.js DeviceOrientationControls
    // 1) Use Y-X-Z order with angles (beta, alpha, -gamma)
    const deg2rad = Math.PI/180;
    const q = qFromEulerYXZ(beta*deg2rad, alpha*deg2rad, -gamma*deg2rad);

    // 2) Rotate from device frame to world (multiply by -90° around X)
    const qxNeg90 = qFromAxisAngle(1,0,0, -Math.PI/2);
    let out = qMultiply(q, qxNeg90);

    // 3) Apply screen orientation (Z-rotation). Use 0 for portrait, +/-90° for landscape.
    const screenAngle = useLandscape ? (Math.PI/2) : 0;
    const qz = qFromAxisAngle(0,0,1, -screenAngle);
    out = qMultiply(out, qz);

    // 4) Apply calibration
    out = qMultiply(qCalib, out);

    return qNormalize(out);
  }

  function updateStatus(txt) {
    statusEl.textContent = txt;
  }

  function requestIOSPermissionIfNeeded() {
    const devMotionPerm = (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function');
    const devOrientPerm = (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function');
    if (devMotionPerm || devOrientPerm) {
      Promise.all([
        devMotionPerm ? DeviceMotionEvent.requestPermission() : Promise.resolve('granted'),
        devOrientPerm ? DeviceOrientationEvent.requestPermission() : Promise.resolve('granted'),
      ]).then((results)=>{
        if (results.every(r=>r==='granted')) {
          updateStatus('Motion Granted');
        } else {
          updateStatus('Permission denied');
        }
      }).catch(()=>updateStatus('Permission request failed'));
    } else {
      updateStatus('Permission not required on this device');
    }
  }

  function connectWS() {
    if (ws && ws.readyState === WebSocket.OPEN) return;
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    const url = `${proto}://${location.host}/ws`;
    ws = new WebSocket(url);
    ws.onopen = () => updateStatus('Connected');
    ws.onclose = () => updateStatus('Disconnected');
    ws.onerror = () => updateStatus('Error');
  }

  function disconnectWS() {
    if (ws) try { ws.close(); } catch(e) {}
    ws = null;
  }

  // Throttled send loop
  function loop(timestamp) {
    if (ws && ws.readyState === WebSocket.OPEN && gotOrientation) {
      if (timestamp - lastSendTime >= sendIntervalMs) {
        const q = computeQuaternion();

        // Optional low-pass smoothing on this side (kept simple—Unity also smooths)
        const payload = {
          type: "orientation",
          q: q, // [x,y,z,w]
          t: Date.now()
        };
        ws.send(JSON.stringify(payload));
        lastSendTime = timestamp;
        debug.textContent = `q: [${q.map(v=>v.toFixed(4)).join(', ')}]\nHz: ${(1000/sendIntervalMs).toFixed(0)}  |  Orientation: ${useLandscape?'landscape':'portrait'}`;
      }
    }
    requestAnimationFrame(loop);
  }

  // Events
  window.addEventListener('deviceorientation', (e) => {
    if (e.absolute !== undefined) { /* can be used if needed */ }
    // Some browsers present nulls until granted
    if (e.alpha == null || e.beta == null || e.gamma == null) return;
    alpha = e.alpha; // z
    beta  = e.beta;  // x
    gamma = e.gamma; // y
    gotOrientation = true;
  }, true);

  // UI
  permBtn.onclick = requestIOSPermissionIfNeeded;
  connectBtn.onclick = connectWS;
  disconnectBtn.onclick = disconnectWS;
  calibBtn.onclick = () => {
    // Capture current as reference: qCalib = conj(qCurrent)
    const qNow = computeQuaternion(); // uses current alpha/beta/gamma + current qCalib, so reset first:
    qCalib = [0,0,0,1];
    const qRaw = computeQuaternion();
    qCalib = qConjugate(qRaw);
    updateStatus('Calibrated');
  };
  smoothing.oninput = () => {
    smoothVal.textContent = (+smoothing.value).toFixed(3);
  };
  rate.oninput = () => {
    rateVal.textContent = rate.value;
    sendIntervalMs = 1000 / (+rate.value);
  };
  orientRadios.forEach(r => r.addEventListener('change', () => {
    useLandscape = document.querySelector('input[name="orient"]:checked').value === 'landscape';
  }));

  updateStatus('Disconnected');
  sendIntervalMs = 1000/(+rate.value);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
