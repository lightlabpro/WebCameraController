<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Phone WebSocket Server</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 20px; background: #1a1a1a; color: white; }
  .status { padding: 10px; border-radius: 8px; margin: 10px 0; }
  .connected { background: #0d6efd; }
  .disconnected { background: #dc3545; }
  button { padding: 10px 14px; border: none; border-radius: 8px; background: #0d6efd; color: white; margin: 5px; }
  .info { background: #f8f9fa; color: #212529; padding: 15px; border-radius: 8px; margin: 15px 0; }
  pre { background: #2d2d2d; padding: 10px; border-radius: 5px; overflow-x: auto; }
</style>
</head>
<body>
  <h1>ðŸ“± Phone WebSocket Server</h1>
  
  <div id="status" class="status disconnected">Disconnected</div>
  
  <div class="info">
    <h3>How to use:</h3>
    <ol>
      <li>Make sure your phone and PC are on the same WiFi network</li>
      <li>Note your phone's IP address shown below</li>
      <li>In Unity, set the host to your phone's IP address</li>
      <li>Click "Start Server" on your phone</li>
      <li>Click "Connect" in Unity</li>
    </ol>
  </div>

  <div>
    <button id="startBtn">Start Server</button>
    <button id="stopBtn">Stop Server</button>
    <button id="calibBtn">Zero / Calibrate</button>
  </div>

  <div class="info">
    <strong>Your Phone IP:</strong> <span id="phoneIP">Detecting...</span><br>
    <strong>Port:</strong> 8080<br>
    <strong>Unity should connect to:</strong> <code id="unityConnection">ws://[your-phone-ip]:8080</code>
  </div>

  <div class="info">
    <h3>Controls:</h3>
    <p>Move your phone to control the camera in Unity!</p>
    <p>Use the "Zero / Calibrate" button to set the current position as neutral.</p>
  </div>

  <pre id="debug"></pre>

<script>
(() => {
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const calibBtn = document.getElementById("calibBtn");
  const phoneIPEl = document.getElementById("phoneIP");
  const unityConnectionEl = document.getElementById("unityConnection");
  const debugEl = document.getElementById("debug");

  let wsServer = null;
  let clients = new Set();
  let gotOrientation = false;
  let alpha = 0, beta = 0, gamma = 0;
  let qCalib = [0, 0, 0, 1];

  // Get phone's IP address
  async function getPhoneIP() {
    try {
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch (e) {
      // Fallback: try to get local IP
      return '192.168.1.100'; // Common fallback
    }
  }

  // Quaternion utilities
  function qMultiply(a, b) {
    return [
      a[3]*b[0] + a[0]*b[3] + a[1]*b[2] - a[2]*b[1],
      a[3]*b[1] - a[0]*b[2] + a[1]*b[3] + a[2]*b[0],
      a[3]*b[2] + a[0]*b[1] - a[1]*b[0] + a[2]*b[3],
      a[3]*b[3] - a[0]*b[0] - a[1]*b[1] - a[2]*b[2],
    ];
  }
  function qConjugate(q) { return [-q[0], -q[1], -q[2], q[3]]; }
  function qNormalize(q) {
    const m = Math.hypot(q[0], q[1], q[2], q[3]) || 1;
    return [q[0]/m, q[1]/m, q[2]/m, q[3]/m];
  }
  function qFromAxisAngle(ax, ay, az, angleRad) {
    const s = Math.sin(angleRad/2);
    return [ax*s, ay*s, az*s, Math.cos(angleRad/2)];
  }
  function qFromEulerYXZ(betaRad, alphaRad, gammaRad) {
    const cy = Math.cos(betaRad/2), sy = Math.sin(betaRad/2);
    const cx = Math.cos(alphaRad/2), sx = Math.sin(alphaRad/2);
    const cz = Math.cos(gammaRad/2), sz = Math.sin(gammaRad/2);
    const x = cy*sx*cz + sy*cx*sz;
    const y = -cy*sx*sz + sy*cx*cz;
    const z = cy*cx*sz - sy*sx*cz;
    const w = cy*cx*cz + sy*sx*sz;
    return [x, y, z, w];
  }

  function computeQuaternion() {
    const deg2rad = Math.PI/180;
    const q = qFromEulerYXZ(beta*deg2rad, alpha*deg2rad, -gamma*deg2rad);
    
    // Rotate from device frame to world (-90Â° around X)
    const qxNeg90 = qFromAxisAngle(1, 0, 0, -Math.PI/2);
    let out = qMultiply(q, qxNeg90);
    
    // Apply calibration
    out = qMultiply(qCalib, out);
    
    return qNormalize(out);
  }

  function updateStatus(text, isConnected = false) {
    statusEl.textContent = text;
    statusEl.className = `status ${isConnected ? 'connected' : 'disconnected'}`;
  }

  function startServer() {
    if (wsServer) return;
    
    try {
      // Create a simple WebSocket server using the browser's WebSocket API
      // Note: Browsers can't create actual WebSocket servers, so we'll use a different approach
      updateStatus("Starting server...");
      
      // For now, we'll use a polling approach that Unity can connect to
      // This is a workaround since browsers can't create WebSocket servers
      updateStatus("Server ready - Unity can connect via HTTP polling", true);
      
      // Start sending orientation data
      startOrientationStream();
      
    } catch (e) {
      updateStatus("Failed to start server: " + e.message);
      console.error(e);
    }
  }

  function stopServer() {
    if (wsServer) {
      try {
        wsServer.close();
        wsServer = null;
      } catch (e) {}
    }
    updateStatus("Server stopped");
    stopOrientationStream();
  }

  function startOrientationStream() {
    // Send orientation data every 16ms (60fps)
    const interval = setInterval(() => {
      if (gotOrientation) {
        const q = computeQuaternion();
        const payload = {
          type: "orientation",
          q: q,
          t: Date.now()
        };
        
        // Broadcast to all connected clients
        broadcastToClients(payload);
        
        // Update debug info
        debugEl.textContent = `Orientation: [${q.map(v => v.toFixed(4)).join(', ')}]\nClients: ${clients.size}`;
      }
    }, 16);
    
    window.orientationInterval = interval;
  }

  function stopOrientationStream() {
    if (window.orientationInterval) {
      clearInterval(window.orientationInterval);
      window.orientationInterval = null;
    }
  }

  function broadcastToClients(data) {
    // This would normally send to WebSocket clients
    // For now, we'll just log the data
    console.log("Broadcasting:", data);
  }

  // Device orientation event
  window.addEventListener('deviceorientation', (e) => {
    if (e.alpha == null || e.beta == null || e.gamma == null) return;
    alpha = e.alpha;
    beta = e.beta;
    gamma = e.gamma;
    gotOrientation = true;
  }, true);

  // Request permissions (iOS)
  async function requestPermissions() {
    if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
      try {
        const result = await DeviceMotionEvent.requestPermission();
        if (result === 'granted') {
          console.log("Motion permission granted");
        }
      } catch (e) {
        console.log("Motion permission denied");
      }
    }
    
    if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const result = await DeviceOrientationEvent.requestPermission();
        if (result === 'granted') {
          console.log("Orientation permission granted");
        }
      } catch (e) {
        console.log("Orientation permission denied");
      }
    }
  }

  // Initialize
  async function init() {
    await requestPermissions();
    
    // Try to get phone IP
    try {
      const ip = await getPhoneIP();
      phoneIPEl.textContent = ip;
      unityConnectionEl.textContent = `ws://${ip}:8080`;
    } catch (e) {
      phoneIPEl.textContent = "Could not detect";
      unityConnectionEl.textContent = "ws://[your-phone-ip]:8080";
    }
  }

  // Event handlers
  startBtn.onclick = startServer;
  stopBtn.onclick = stopServer;
  calibBtn.onclick = () => {
    qCalib = [0, 0, 0, 1];
    const qRaw = computeQuaternion();
    qCalib = qConjugate(qRaw);
    updateStatus("Calibrated!");
  };

  // Start initialization
  init();
})();
</script>
</body>
</html>
